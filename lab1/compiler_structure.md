# 编译过程概述

在我们刚开始学编程的时候，代码的执行对我们来说就像是魔法一样：我们输入一些字符串，并且把它们交给编译器，当时对我们来说，编译器仅仅意味着"IDE 上的运行按钮"（或者是命令行里面的一串神秘指令），我们要做的就是写好代码，点击这个按钮，这些字符串就神奇地运行起来（~~或者是神奇地报错~~）了。

在我们接触了汇编语言以后，我们知道了我们输入的字符串会被编译为汇编语言（对于编译型语言来说），这些汇编语言能够直接在 CPU 上跑起来并实现我们的目标，我们也能够自己手动编写一些简单的汇编程序（比如写一个排序函数或者是让屏幕上闪烁炫酷的 RGB 字符）。

上方的门和下方的门都打开了，但现在我们眼前还有一个问题：我们输入的源语言是怎么变成汇编语言的呢？

我们都知道答案是编译器，但编译器**具体**是怎么做的，现在我们还不清楚，所幸，我们将在接下来的旅程中弄明白这个问题。[^1]

[^1]: 剧透：是蛋先生的鸡，世界上第一个编译器是用汇编语言写的。

> 这一节的主要任务是针对编译的过程进行一个总体性质的介绍，目的是让同学们对编译的理解不再流于书本上的描述，并对编译过程形成一个大致的，能够将想法映射到代码上的印象：编译器有哪些部分，他们有什么功能，他们是如何合作的，我该怎么实现。而具体的实现指导与技术点，我们将在各个 step 中进行详细的介绍。如果将来报道出现了偏差，以每个 step 中具体的要求为准。
> 计算机最重要的思想之一就是分层抽象，在任意两层之间，还可以按照设计者的意愿再次添加抽象层。而软件架构的设计和实现，是为了解决现实世界的具体问题，会面临资源、财力、物力、人力、时间等多种因素的掣肘，就会诞生一些“不那么规矩”、“不那么单纯”的架构或组件/软件，它们往往会跨层次，跨模块，大模块拆小，小模块合并，甚至打破一些“金科玉律”等等。
> 所以，相比于弄懂一个名词，更多的精力应该放在理解事物的本质上，只要把解决问题的流程和方法弄明白了，解决问题的过程中所用到的子流程、工具、方法，你爱怎么叫怎么叫，甚至自己发明名词也可以（只是与外人沟通可能会不太顺畅）。[^2]

[^2]:  引自 https://github.com/rcore-os/rCore-Tutorial-Book-v3/issues/71

------

一个常见的编译器大致分为三个部分：前端，中端与后端，他们分别承担了以下的任务

- 编译器前端会将源程序读入，在进行**词法分析**和**语法分析**以后将源程序转化为一个抽象语法树 (Abstract Syntax Tree,**AST**)，并在此基础上对语法树进行扫描，对其进行**语义分析**，检查是否有语义错误。
- 编译器的中端会对** AST **进行扫描，并生成对应的一层或者是多层的 IR，并对其进行优化。
- 编译器的后端通常会将 IR 转化为具体体系结构的**汇编代码** (MIPS,x86,arm,RISC-V...)，并在这个基础上做一些面向体系结构的优化。

那我们的实验最后实现的编译器和常见的编译器有什么区别呢？

1. 实际上现在大多数编译器的实现方式都是手写递归下降（比如 GCC 曾经使用的就是 YACC（BISON）的解决方案，[但他们在 3.x 的时候放弃了这个方案](http://gcc.gnu.org/wiki/New_C_Parser )），使用 ANTLR/FLEX/BISON/其他辅助分析工具的编译器比较少，因为对于不断变动和改进的语言来说，递归下降解析器是便于理解，编写和调试的。
   **但是**，我们的示例编译器仍然使用了分析工具。对于不会变动的语言，使用辅助工具不失是一个比较好的选择。而且不是每位同学以后都会从事编译相关的工作，能够手写递归下降解析固然很酷炫，但掌握这些工具却确实可能会在某些情况下帮上大忙。
2. 我们的编译器对错误处理的要求是比较低的，当检测到错误时只需要以一个非 0 值退出就行。但这并不代表错误处理是不重要的，实际上，一个错误处理做得好的编译器能给程序员的编程体验带来很大的提升。
3. 我们在中端部分几乎只进行生成 LLVM IR 这一步，一些简单的优化将会作为挑战实验发布。
4. 我们的编译器没有传统意义上的后端，我们的实验将止步于输出 LLVM IR，这意味着你不用。

## 词法分析和语法分析
