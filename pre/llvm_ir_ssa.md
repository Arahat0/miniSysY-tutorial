# SSA 以及LLVM IR 中的变量

如果看完本节以后还有感到迷惑的地方可以看下面这个视频

[B站源](https://www.bilibili.com/video/BV1oE411y711)     [油管源](https://www.youtube.com/watch?v=m8G_S5LwlTo)

在阅读本节前我们默认你已经阅读过了 [LLVM IR 快速上手](https://buaa-se-compiling.github.io/miniSysY-tutorial/pre/llvm_ir_quick_primer.html)一节。

在 LLVM IR 中，变量是以SSA形式存在的，为了生成正确的LLVM IR并实现我们的实验，对SSA的知识是必不可少的，LLVM IR的SSA分为两种形式存在，分别是以Load Store形式存在的SSA以及以PHI形式存在的SSA。本小节将对SSA进行简单的介绍，并指导大家设计合适的中间代码架构，以免实验到了后期因为设计问题出现大幅度重构。

在基础实验中，你只需要实现较简单的Load Store形式的SSA，而生成PHI形式的SSA将被我们作为挑战实验发布。

## SSA 介绍

> 在编译器的设计中，**静态单赋值形式**（static single assignment form，通常简写为**SSA form**或是**SSA**）是中间表示（IR，intermediate representation)的特性，每个变量仅被赋值一次。——维基百科

在IR中，每个变量都在使用前都必须先定义，且每个变量只能被赋值一次（如果套用C++的术语，就是说每个变量只能被初始化，不能被赋值），所以我们称IR是静态单一赋值的。
举一个例子，如果想要返回 `1*2+3`的值，我们下意识地就会像这样写。

```llvm
%0 = mul i32 1, 2
%0 = add i32 %0, 3
ret i32 %0
```

很合理，不是吗？但这样写实际上是错的，因为变量`%0`被赋值了两次。我们需要修改为

```llvm
%0 = mul i32 1, 2
%1 = add i32 %0, 3
ret i32 %1
```

**SSA的好处（拓展阅读）**

对人类来说，第一种做法似乎更为直观，但是对于编译器来说，第二种做法带来的好处更多。

SSA可以简化编译器的优化过程，譬如说，考虑这段代码

``` 
d1: y := 1
一些无关代码
d2: y := 2
一些无关代码
d3: x := y
```

我们很容易可以看出第一次对`y`赋值是不必要的，在对`x`赋值时使用的`y`的值时第二次赋值的结果，但是编译器必须要经过一个定义可达性(Reaching definition)分析才能做出判断。编译器是怎么分析呢？首先我们先介绍几个概念（这些概念将会在我们课程的后半部分出现，我们在这里先 look ahead 一下，不完全理解也不影响实验的进行）：

- 定义：对变量`x`进行定义的意思是在某处会/可能给`x`进行赋值，比如上面的`d1`处就是一个对`y`的定义。
- kill：当一个变量有了新的定义后，旧有的定义就会被`kill`掉，在上面的语句中`d2`就`kill`掉了`d1`中对y的定义
- 定义到达某点：定义`p`到达某点`q`的意思是存在一条路径，沿着这条路径行进，`p`在到达到点`q`之前不会被`kill`掉。
- reaching definition：`a`是`b`的reaching definition 的意思是存在一条从`a`到达`b`的路径，沿着这条路径走可以自然得到`a`要赋值的变量的值，而不需要额外的信息。 

按照上面的写法，`d1`便不再是`d3`的reaching definition,因为`d2`使它不再可能被到达。

对我们来说，这件事情是一目了然的，但是如果控制流再复杂一点，对于编译器来说，它便无法确切知道`d3`的reaching definition是`d1`或者`d2`了，也不清楚`d1`和`d2`到底是谁`kill`了谁。但是，如果我们的代码是SSA的，那它就会长成这样。

```
d1: y1 := 1
一些无关代码
d2: y2 := 2
一些无关代码
d3: x := y2
```

编译器很容易就能够发现`x`是由`y2`赋值得到，而`y2`被赋值了2，且`x`和`y2`都只能被赋值一次，显然得到`x`的值的路径就是唯一确定的，`d2`就是`d3`的reaching definition。

**SSA带来的麻烦事**

## 一些实现指导